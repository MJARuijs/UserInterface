package userinterface.animationimport math.Colorimport math.vectors.Vectorimport math.vectors.Vector2import math.vectors.Vector3import math.vectors.Vector4import userinterface.NoSuchPropertyExceptionimport kotlin.math.absclass ValueAnimation(val duration: Float, private val newValue: Any, private val type: ValueType, private val animationType: AnimationType, val item: Any) : Animation() {        private var started = false    private var finished = false        private val size = when (newValue) {        is Float -> 1        is Vector2 -> 2        is Vector3 -> 3        is Vector4 -> 4        is Color -> 4        else -> throw IllegalArgumentException()    }        private lateinit var goalValue: Any        private var speed = FloatArray(size)        override fun apply(deltaTime: Float): Boolean {        val getMethod = item::class.java.methods.find { method -> method.name.toLowerCase() == "get${type.parameterName.toLowerCase()}" } ?: throw NoSuchPropertyException("Property with name: ${type.parameterName} does not exist, or does not have an accessible getter in class ${item.javaClass.simpleName}")        val setMethod = item::class.java.methods.find { method -> method.name.toLowerCase() == "set${type.parameterName.toLowerCase()}" } ?: throw NoSuchPropertyException("Property with name: ${type.parameterName} does not exist, or does not have an accessible setter in class ${item.javaClass.simpleName}")            val currentValue = when (val current = getMethod.invoke(item)) {            is Float -> floatArrayOf(current)            is Vector<*> -> current.toArray()            is Color -> current.toArray()            else -> throw IllegalArgumentException()        }                if (!started) {            started = true                        goalValue = when (animationType) {                AnimationType.ADD_TO_CURRENT -> {                    when (newValue) {                        is Float -> floatArrayOf(newValue + currentValue[0])                        is Vector<*> -> floatArrayOf(newValue[0] + currentValue[0], newValue[1] + currentValue[1], newValue[2] + currentValue[2], 1.0f)                        is Color -> floatArrayOf(newValue[0] + currentValue[0], newValue[1] + currentValue[1], newValue[2] + currentValue[2], 1.0f)                        else -> throw IllegalArgumentException()                    }                }                AnimationType.SET -> {                    when (newValue) {                        is Float -> floatArrayOf(newValue)                        is Vector<*> -> newValue.toArray()                        is Color -> newValue.toArray()                        else -> throw IllegalArgumentException()                    }                }            }                        for (i in 0 until size) {                if (newValue is Color) {                    speed[i] = ((goalValue as FloatArray)[i] + currentValue[i]) / duration                } else {                    speed[i] = ((goalValue as FloatArray)[i] - currentValue[i]) / duration                }            }        }            for (i in 0 until size) {            val increase = deltaTime * speed[i]            if (abs(currentValue[i] - (goalValue as FloatArray)[i]) < abs(increase)) {                finished = true            } else {                currentValue[i] += increase            }        }                if (finished) {            when (newValue) {                is Float -> setMethod.invoke(item, (goalValue as FloatArray)[0])                is Vector2 -> setMethod.invoke(item, Vector2((goalValue as FloatArray)[0], (goalValue as FloatArray)[1]))                is Vector3 -> setMethod.invoke(item, Vector3((goalValue as FloatArray)[0], (goalValue as FloatArray)[1], (goalValue as FloatArray)[2]))                is Vector4 -> setMethod.invoke(item, Vector4((goalValue as FloatArray)[0], (goalValue as FloatArray)[1], (goalValue as FloatArray)[2], (goalValue as FloatArray)[3]))                is Color -> setMethod.invoke(item, Vector4((goalValue as FloatArray)[0], (goalValue as FloatArray)[1], (goalValue as FloatArray)[2], (goalValue as FloatArray)[3]))            }            return true        } else {            when (newValue) {                is Float -> setMethod.invoke(item, currentValue[0])                is Vector2 -> setMethod.invoke(item, Vector2(currentValue[0], currentValue[1]))                is Vector3 -> setMethod.invoke(item, Vector3(currentValue[0], currentValue[1], currentValue[2]))                is Vector4 -> setMethod.invoke(item, Vector4(currentValue[0], currentValue[1], currentValue[2], currentValue[3]))                is Color -> setMethod.invoke(item, Vector4(currentValue[0], currentValue[1], currentValue[2], currentValue[3]))            }        }        return false    }}