package userinterface.svgimport math.vectors.Vector2class Triangulation {        private val epsilon = 0.0000000001f        private fun computeArea(contour: ArrayList<Vector2>): Float {        val n = contour.size                var area = 0.0f        var p = n - 1        var q = 0                while (q < n) {            area += contour[p].x * contour[q].y - contour[q].x * contour[p].y            p = q++        }                return area * 0.5f    }        private fun isInsideTriangle(a: Vector2, b: Vector2, c: Vector2, point: Vector2): Boolean {        val cMinB = c - b        val aMinC = a - c        val bMinA = b - a                val pMinA = point - a        val pMinB = point - b        val pMinC = point - c                val cross1 = cMinB.x * pMinB.y - cMinB.y * pMinB.x        val cross2 = bMinA.x * pMinA.y - bMinA.y * pMinA.x        val cross3 = aMinC.x * pMinC.y - aMinC.y * pMinC.x                val Ax = a.x        val Ay = a.y        val Bx = b.x        val By = b.y        val Cx = c.x        val Cy = c.y        val Px = point.x        val Py = point.y            val ax: Float        val ay: Float        val bx: Float        val by: Float        val cx: Float        val cy: Float        val apx: Float        val apy: Float        val bpx: Float        val bpy: Float        val cpx: Float        val cpy: Float        val cCROSSap: Float        val bCROSScp: Float        val aCROSSbp: Float            ax = Cx - Bx        ay = Cy -By        bx = Ax - Cx        by = Ay -Cy        cx = Bx - Ax        cy = By -Ay        apx = Px - Ax        apy = Py -Ay        bpx = Px - Bx        bpy = Py -By        cpx = Px - Cx        cpy = Py -Cy            aCROSSbp = ax * bpy - ay * bpx        cCROSSap = cx * apy - cy * apx        bCROSScp = bx * cpy - by * cpx            return ((aCROSSbp >= 0.0f) && (bCROSScp >= 0.0f) && (cCROSSap >= 0.0f));//        return cross1 >= 0.0f && cross2 >= 0.0f && cross3 >= 0.0f    }        private fun snip(contour: ArrayList<Vector2>, u: Int, v: Int, w: Int, n: Int, ints: IntArray): Boolean {        val a = contour[ints[u]]        val b = contour[ints[v]]        val c = contour[ints[w]]        if (epsilon > (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)) {            return false        }                for (p in 0 until n) {            if ((p == u) || (p == v) || (p == w)) {                continue            }            val point = contour[ints[p]]            if (isInsideTriangle(a, b, c, point)) {                return false            }        }        return true    }        fun process(contour: ArrayList<Vector2>): ArrayList<Vector2>? {        val n = contour.size        val result = ArrayList<Vector2>()                if (n < 3) {            println("Less than 3")            return null        }                val ints = IntArray(n)                if (0.0f < computeArea(contour)) {            for (v in 0 until n) {                ints[v] = v            }        } else {            for (v in 0 until n) {                ints[v] = (n - 1) - v            }        }                var nv = n                var count = 2 * nv                var m = 0        var v = nv - 1        while (nv > 2) {            if (0 >= count--) {//                println("kek")                return result            }            var u = v            if (nv <= u) {                u = 0            }            v = u + 1            if (nv <= v) {                v = 0            }            var w = v + 1            if (nv <= w) {                w = 0            }                        if (snip(contour, u, v, w, nv, ints)) {                val a = ints[u]                val b = ints[v]                val c = ints[w]                                result += contour[a]                result += contour[b]                result += contour[c]                                m++                                var s = v                var t = v + 1                while (t < nv) {                    ints[s] = ints[t]                                        s++                    t++                }                nv--                    count = 2 * nv            }        }        return result    }    }