package userinterface.animation.effectsimport math.vectors.Vector2import userinterface.MovableUIContainerimport userinterface.UniversalParameters.ANIMATION_DURATIONimport userinterface.animation.Animationimport userinterface.animation.AnimationTypeimport userinterface.animation.ValueAnimationimport userinterface.animation.ValueTypeimport userinterface.items.Itemclass TranslationEffect(private val xTranslation: Float, private val yTranslation: Float, duration: Float = ANIMATION_DURATION) : Effect(duration) {        constructor(translation: Vector2, duration: Float = ANIMATION_DURATION) : this(translation.x, translation.y, duration)        override fun applyOn(item: Item): ArrayList<Pair<MovableUIContainer, Animation>> {        val animations = ArrayList<Pair<MovableUIContainer, Animation>>()        if (xTranslation != 0.0f) {            animations += Pair(item, ValueAnimation(duration, xTranslation, ValueType.TRANSLATION_X, AnimationType.ADD_TO_CURRENT, item))        }        if (yTranslation != 0.0f) {            animations += Pair(item, ValueAnimation(duration, yTranslation, ValueType.TRANSLATION_Y, AnimationType.ADD_TO_CURRENT, item))        }        return animations    }        override fun removeFrom(item: Item): ArrayList<Pair<MovableUIContainer, Animation>> {        val animations = ArrayList<Pair<MovableUIContainer, Animation>>()            if (xTranslation != 0.0f) {            animations += Pair(item, ValueAnimation(duration, -xTranslation, ValueType.TRANSLATION_X, AnimationType.ADD_TO_CURRENT, item))        }        if (yTranslation != 0.0f) {            animations += Pair(item, ValueAnimation(duration, -yTranslation, ValueType.TRANSLATION_Y, AnimationType.ADD_TO_CURRENT, item))        }        return animations    }}